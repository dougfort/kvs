{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.18.2","compilation":{"directory":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48],"program":"/home/dougfort/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rls","arguments":["--crate-name","float_cmp","/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","--color","never","--crate-type","lib","--emit=dep-info,metadata","-C","debuginfo=2","-C","metadata=49eac8b765aedd11","-C","extra-filename=-49eac8b765aedd11","--out-dir","/home/dougfort/rust/kvs/target/rls/debug/deps","-L","dependency=/home/dougfort/rust/kvs/target/rls/debug/deps","--extern","num_traits=/home/dougfort/rust/kvs/target/rls/debug/deps/libnum_traits-f70fbba1b5334996.rmeta","--cap-lints","allow","--error-format=json","--sysroot","/home/dougfort/.rustup/toolchains/stable-x86_64-unknown-linux-gnu"],"output":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,114,117,115,116,47,107,118,115,47,116,97,114,103,101,116,47,114,108,115,47,100,101,98,117,103,47,100,101,112,115,47,108,105,98,102,108,111,97,116,95,99,109,112,45,52,57,101,97,99,56,98,55,54,53,97,101,100,100,49,49,46,114,109,101,116,97]},"prelude":{"crate_id":{"name":"float_cmp","disambiguator":[12544232998543449850,11850453312465231061]},"crate_root":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src","external_crates":[{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[1137707474377317163,881293823083572693]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[16254816028303588237,6669189139375923666]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[7111806954579578569,2199841390691958019]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[6021837240640825503,11520007856923678909]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[12444724012878050064,2416873571855687959]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[6979589238717360547,5382701582921578244]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[14383072016947483551,11019396538837452451]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":8,"id":{"name":"rustc_demangle","disambiguator":[15664728184530138178,15668582881963515515]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":9,"id":{"name":"backtrace_sys","disambiguator":[16547370833325286379,14798728708606514427]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":10,"id":{"name":"panic_unwind","disambiguator":[3405404226459150258,2890948387317429027]}},{"file_name":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","num":11,"id":{"name":"num_traits","disambiguator":[14094366829404869551,11339159500179849023]}}],"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":113,"byte_end":5343,"line_start":4,"line_end":128,"column_start":1,"column_end":36}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":14},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":5148,"byte_end":5152,"line_start":116,"line_end":116,"column_start":21,"column_end":25},"alias_span":null,"name":"Ulps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":38},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":5191,"byte_end":5203,"line_start":119,"line_end":119,"column_start":24,"column_end":36},"alias_span":null,"name":"ApproxEqUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":74},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":5244,"byte_end":5257,"line_start":122,"line_end":122,"column_start":25,"column_end":38},"alias_span":null,"name":"ApproxOrdUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":106},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":5286,"byte_end":5294,"line_start":125,"line_end":125,"column_start":19,"column_end":27},"alias_span":null,"name":"ApproxEq","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":142},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":5329,"byte_end":5342,"line_start":128,"line_end":128,"column_start":22,"column_end":35},"alias_span":null,"name":"ApproxEqRatio","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,108,105,98,46,114,115],"byte_start":113,"byte_end":5343,"line_start":4,"line_end":128,"column_start":1,"column_end":36},"name":"","qualname":"::","value":"/home/dougfort/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.4.0/src/lib.rs","parent":null,"children":[{"krate":0,"index":2},{"krate":0,"index":4},{"krate":0,"index":6},{"krate":0,"index":8},{"krate":0,"index":32},{"krate":0,"index":34},{"krate":0,"index":58},{"krate":0,"index":60},{"krate":0,"index":94},{"krate":0,"index":96},{"krate":0,"index":126},{"krate":0,"index":128},{"krate":0,"index":152}],"decl_id":null,"docs":" # float-cmp","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":14},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,46,114,115],"byte_start":5672,"byte_end":5676,"line_start":9,"line_end":9,"column_start":11,"column_end":15},"name":"Ulps","qualname":"::ulps::Ulps","value":"Ulps","parent":null,"children":[{"krate":0,"index":16},{"krate":0,"index":18}],"decl_id":null,"docs":" A trait for floating point numbers which computes the number of representable\n values or ULPs (Units of Least Precision) that separate the two given values.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":16},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,46,114,115],"byte_start":5688,"byte_end":5689,"line_start":10,"line_end":10,"column_start":10,"column_end":11},"name":"U","qualname":"::ulps::Ulps::U","value":"type U: Copy + NumCast;","parent":{"krate":0,"index":14},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":18},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,46,114,115],"byte_start":5939,"byte_end":5943,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"ulps","qualname":"::ulps::Ulps::ulps","value":"fn (&self, other: &Self) -> <Self as Ulps>::U","parent":{"krate":0,"index":14},"children":[],"decl_id":null,"docs":" The number of representable values or ULPs (Units of Least Precision) that\n separate `self` and `other`.  The result `U` is an integral value, and will\n be zero if `self` and `other` are exactly equal.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":38},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,101,113,46,114,115],"byte_start":9896,"byte_end":9908,"line_start":10,"line_end":10,"column_start":11,"column_end":23},"name":"ApproxEqUlps","qualname":"::ulps_eq::ApproxEqUlps","value":"ApproxEqUlps","parent":null,"children":[{"krate":0,"index":40},{"krate":0,"index":42},{"krate":0,"index":44}],"decl_id":null,"docs":" ApproxEqUlps is a trait for approximate equality comparisons.\n The associated type Flt is a floating point type which implements Ulps, and is\n required so that this trait can be implemented for compound types (e.g. vectors),\n not just for the floats themselves.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":40},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,101,113,46,114,115],"byte_start":9920,"byte_end":9923,"line_start":11,"line_end":11,"column_start":10,"column_end":13},"name":"Flt","qualname":"::ulps_eq::ApproxEqUlps::Flt","value":"type Flt: Ulps;","parent":{"krate":0,"index":38},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":42},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,101,113,46,114,115],"byte_start":10283,"byte_end":10297,"line_start":18,"line_end":18,"column_start":8,"column_end":22},"name":"approx_eq_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_eq_ulps","value":"fn (&self, other: &Self, ulps: <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":38},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":44},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,101,113,46,114,115],"byte_start":10728,"byte_end":10742,"line_start":26,"line_end":26,"column_start":8,"column_end":22},"name":"approx_ne_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_ne_ulps","value":"fn (&self, other: &Self, ulps: <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":38},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately\n equal within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,101,113,46,114,115],"byte_start":10711,"byte_end":10720,"line_start":25,"line_end":25,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":74},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":14062,"byte_end":14075,"line_start":10,"line_end":10,"column_start":11,"column_end":24},"name":"ApproxOrdUlps","qualname":"::ulps_ord::ApproxOrdUlps","value":"ApproxOrdUlps: ApproxEqUlps","parent":null,"children":[{"krate":0,"index":76},{"krate":0,"index":78},{"krate":0,"index":80},{"krate":0,"index":82},{"krate":0,"index":84}],"decl_id":null,"docs":" ApproxOrdUlps is for sorting floating point values where approximate equality\n is considered equal.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":76},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":14371,"byte_end":14386,"line_start":15,"line_end":15,"column_start":8,"column_end":23},"name":"approx_cmp_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_cmp_ulps","value":"fn (&self, other: &Self, ulps: <<Self as ApproxEqUlps>::Flt as Ulps>::U) -> Ordering","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" This method returns an ordering between `self` and `other` values\n if one exists, where Equal is returned if they are approximately\n equal within `ulps` floating point representations.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":78},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":14708,"byte_end":14722,"line_start":22,"line_end":22,"column_start":8,"column_end":22},"name":"approx_lt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_lt_ulps","value":"fn (&self, other: &Self, ulps: <<Self as ApproxEqUlps>::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" This method tests less than (for `self` < `other`), where values\n within `ulps` of each other are not less than.  See module\n documentation for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":14691,"byte_end":14700,"line_start":21,"line_end":21,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":80},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":15160,"byte_end":15174,"line_start":35,"line_end":35,"column_start":8,"column_end":22},"name":"approx_le_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_le_ulps","value":"fn (&self, other: &Self, ulps: <<Self as ApproxEqUlps>::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" This method tests less than or equal to (for `self` <= `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":15143,"byte_end":15152,"line_start":34,"line_end":34,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":82},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":15630,"byte_end":15644,"line_start":48,"line_end":48,"column_start":8,"column_end":22},"name":"approx_gt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_gt_ulps","value":"fn (&self, other: &Self, ulps: <<Self as ApproxEqUlps>::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" This method tests greater than (for `self` > `other`)\n where values within `ulps` are not greater than.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":15613,"byte_end":15622,"line_start":47,"line_end":47,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":84},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":16087,"byte_end":16101,"line_start":61,"line_end":61,"column_start":8,"column_end":22},"name":"approx_ge_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_ge_ulps","value":"fn (&self, other: &Self, ulps: <<Self as ApproxEqUlps>::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":74},"children":[],"decl_id":null,"docs":" This method tests greater than or equal to (for `self` > `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":16070,"byte_end":16079,"line_start":60,"line_end":60,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":106},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,101,113,46,114,115],"byte_start":24395,"byte_end":24403,"line_start":10,"line_end":10,"column_start":11,"column_end":19},"name":"ApproxEq","qualname":"::eq::ApproxEq","value":"ApproxEq","parent":null,"children":[{"krate":0,"index":108},{"krate":0,"index":110},{"krate":0,"index":112}],"decl_id":null,"docs":" ApproxEq is a trait for approximate equality comparisons. The associated type Flt is a\n floating point type which implements Ulps, and is required so that this trait can be\n implemented for compound types (e.g. vectors),/ not just for the floats themselves.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":108},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,101,113,46,114,115],"byte_start":24415,"byte_end":24418,"line_start":11,"line_end":11,"column_start":10,"column_end":13},"name":"Flt","qualname":"::eq::ApproxEq::Flt","value":"type Flt: Ulps;","parent":{"krate":0,"index":106},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":110},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,101,113,46,114,115],"byte_start":25127,"byte_end":25136,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"approx_eq","qualname":"::eq::ApproxEq::approx_eq","value":"fn (&self, other: &Self, epsilon: Self::Flt, ulps: <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":106},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n using two methods: epsilon and ulps.  If the values differ by less than the\n given epsilon, they will be considered equal. If the values differ by more\n than epsilon, but by less than the given ulps, they will also be considered\n equal. Otherwise they are unequal.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":112},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,101,113,46,114,115],"byte_start":25939,"byte_end":25948,"line_start":36,"line_end":36,"column_start":8,"column_end":17},"name":"approx_ne","qualname":"::eq::ApproxEq::approx_ne","value":"fn (&self, other: &Self, epsilon: Self::Flt, ulps: <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":106},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately equal\n using two methods: epsilon and ulps.  If the values differ by less than the\n given epsilon, they will be considered equal. If the values differ by more\n than epsilon, but by less than the given ulps, they will also be considered\n equal. Otherwise they are unequal.","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":142},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30396,"byte_end":30409,"line_start":10,"line_end":10,"column_start":11,"column_end":24},"name":"ApproxEqRatio","qualname":"::ratio::ApproxEqRatio","value":"ApproxEqRatio: Div<Output = Self> + Sub<Output = Self> + Neg<Output = Self> + PartialOrd +\nZero + Sized + Copy","parent":null,"children":[{"krate":0,"index":144},{"krate":0,"index":146}],"decl_id":null,"docs":" ApproxEqRatio is a trait for approximate equality comparisons bounding the ratio\n of the difference to the larger.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":144},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30759,"byte_end":30774,"line_start":16,"line_end":16,"column_start":8,"column_end":23},"name":"approx_eq_ratio","qualname":"::ratio::ApproxEqRatio::approx_eq_ratio","value":"fn (&self, other: &Self, ratio: Self) -> bool","parent":{"krate":0,"index":142},"children":[],"decl_id":null,"docs":" This method tests if `self` and `other` are nearly equal by bounding the\n difference between them to some number much less than the larger of the two.\n This bound is set as the ratio of the difference to the larger.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":146},"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":31930,"byte_end":31945,"line_start":51,"line_end":51,"column_start":8,"column_end":23},"name":"approx_ne_ratio","qualname":"::ratio::ApproxEqRatio::approx_ne_ratio","value":"fn (&self, other: &Self, ratio: Self) -> bool","parent":{"krate":0,"index":142},"children":[],"decl_id":null,"docs":" This method tests if `self` and `other` are not nearly equal by bounding the\n difference between them to some number much less than the larger of the two.\n This bound is set as the ratio of the difference to the larger.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":31913,"byte_end":31922,"line_start":50,"line_end":50,"column_start":5,"column_end":14}}]}],"impls":[],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,117,108,112,115,95,111,114,100,46,114,115],"byte_start":14077,"byte_end":14089,"line_start":10,"line_end":10,"column_start":26,"column_end":38},"kind":"SuperTrait","from":{"krate":0,"index":38},"to":{"krate":0,"index":74}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30412,"byte_end":30415,"line_start":10,"line_end":10,"column_start":27,"column_end":30},"kind":"SuperTrait","from":{"krate":2,"index":1806},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30433,"byte_end":30436,"line_start":10,"line_end":10,"column_start":48,"column_end":51},"kind":"SuperTrait","from":{"krate":2,"index":1790},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30454,"byte_end":30457,"line_start":10,"line_end":10,"column_start":69,"column_end":72},"kind":"SuperTrait","from":{"krate":2,"index":1826},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30479,"byte_end":30489,"line_start":11,"line_end":11,"column_start":7,"column_end":17},"kind":"SuperTrait","from":{"krate":2,"index":2480},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30492,"byte_end":30496,"line_start":11,"line_end":11,"column_start":20,"column_end":24},"kind":"SuperTrait","from":{"krate":11,"index":468},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30499,"byte_end":30504,"line_start":11,"line_end":11,"column_start":27,"column_end":32},"kind":"SuperTrait","from":{"krate":2,"index":1720},"to":{"krate":0,"index":142}},{"span":{"file_name":[47,104,111,109,101,47,100,111,117,103,102,111,114,116,47,46,99,97,114,103,111,47,114,101,103,105,115,116,114,121,47,115,114,99,47,103,105,116,104,117,98,46,99,111,109,45,49,101,99,99,54,50,57,57,100,98,57,101,99,56,50,51,47,102,108,111,97,116,45,99,109,112,45,48,46,52,46,48,47,115,114,99,47,114,97,116,105,111,46,114,115],"byte_start":30507,"byte_end":30511,"line_start":11,"line_end":11,"column_start":35,"column_end":39},"kind":"SuperTrait","from":{"krate":2,"index":1724},"to":{"krate":0,"index":142}}]}